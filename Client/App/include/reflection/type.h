#pragma once
#include <boost/any.hpp>
#include <typeinfo>
#include <list>
#include <vector>
#include "reflection/descriptor.h"

namespace RBX
{
	namespace Reflection
	{
        typedef std::vector<class Value> ValueCollection;

		class Type : public Descriptor
		{
		public:
			const type_info& type;
			const Name& tag;
		  
		public:
			bool operator==(const Type& other) const
			{
				return this == &other;
			}
			bool operator!=(const Type& other) const
			{
				return this != &other;
			}

		protected:
			Type(const char* name, const type_info& type, const char* tag) // TODO: check if matches (will only match in a /GS project)
				: Descriptor(name),
				  type(type),
				  tag(Name::declare(tag, -1))
			{
			}
			Type(const char* name, const type_info& type)
				: Descriptor(name),
				  type(type),
				  tag(Name::lookup(name))
			{
			}

		public:
			template<typename T>
			static const Type& singleton();
		};

		class RefType : public Type
		{
		private:
			RefType(const char* name, const type_info& type)
				: Type(name, type, "Ref")
			{
			}

		public:
			template<typename T>
			static const RefType& singleton()
			{
				static RefType type("Object", typeid(RefType));
				return type;
			}
		};

		class Value
		{
		private:
			const Type* _type;
			boost::any value;
		  
		public:
			// TODO: check ctor
			Value();

			// TODO: this is autogenerated
			template<typename ValueType>
			Value(typename ValueType& value)
				: _type(&Type::singleton<typename ValueType>()),
				  value(value)
			{
			}

		public:
			const Type& type() const
			{
				return *_type;
			}
			bool isVoid() const
			{
				// this is a guess
				return isType<void>();
			}

		public:
			template<typename T>
			T cast() const
			{
				return boost::any_cast<T>(value);
			}

			// not in resym but it might exist
			template<typename T>
			T cast()
			{
				return boost::any_cast<T>(value);
			}

			template<typename T>
			T& convert();

			template<typename T>
			T& genericConvert();

			template<typename T>
			T get() const;

			template<typename T>
			bool isType() const
			{
				return typeid(T) == type().type;
			}

			template<typename T>
			Value& operator=(const T& rhs)
			{
				this->_type = &Type::singleton<T>();
				this->value = rhs;
				return *this;
			}

			// TODO: replace all mentions with operator=?
			template<typename T>
			void set(const T& value)
			{
				this->_type = &Type::singleton<T>();
				this->value = value;
			}
		};

		class SignatureDescriptor
		{
		public:
			struct Item
			{
			public:
				const Name* name;
				const Type* type;
				const Value defaultValue;
			  
			// TODO: these are all autogenerated
			public:
				//template<typename ValueType>
				//Item(const char* name)
				//	: name(&Name::declare(name, -1)),
				//	  type(&Type::singleton<typename ValueType>()),
				//	  defaultValue()
				//{
				//}
				// TODO: This constructor must be templated since it does not appear in the PDB/resym
				// However, we can not use the templated constructor...
				// Bruh.
				// btw this doesnt match either lol
				Item(const Name& name, const Type& type)
					: name(&name),
					  type(&type),
					  defaultValue()
				{
				}
				~Item() {}
			};

		public:
			const Type* resultType;
			std::list<Item> arguments;
		  
		public:
			void addArgument(const Name& name, const Type& type, const Value& defaultValue);

		public:
			SignatureDescriptor();
			~SignatureDescriptor(); // TODO: this is autogenerated
		};
	}
}
